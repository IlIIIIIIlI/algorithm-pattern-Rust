
<!DOCTYPE HTML>
<html lang="zh-hans" >
    <head>
        <meta charset="UTF-8">
        <title>算法快速入门 · JiangMing Gitbook</title>
        <meta http-equiv="X-UA-Compatible" content="IE=edge" />
        <meta name="description" content="">
        <meta name="generator" content="HonKit 5.1.4">
        <meta name="author" content="JiangMing">
        <meta name="identifier" content="000-0-00-000000-0" scheme="ISBN">
        
    
    <link rel="stylesheet" href="../gitbook/style.css">

    
            
                
                <link rel="stylesheet" href="../gitbook/@honkit/honkit-plugin-highlight/website.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-search/search.css">
                
            
                
                <link rel="stylesheet" href="../gitbook/gitbook-plugin-fontsettings/website.css">
                
            
        

    

    
        
    
        
    
        
    
        
    
        
    
        
    

        
    
    
    <meta name="HandheldFriendly" content="true"/>
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="../gitbook/images/apple-touch-icon-precomposed-152.png">
    <link rel="shortcut icon" href="../gitbook/images/favicon.ico" type="image/x-icon">

    
    <link rel="next" href="../data_structure/binary_tree.html" />
    
    
    <link rel="prev" href="golang.html" />
    

    </head>
    <body>
        
<div class="book honkit-cloak">
    <div class="book-summary">
        
            
<div id="book-search-input" role="search">
    <input type="text" placeholder="输入并搜索" />
</div>

            
                <nav role="navigation">
                


<ul class="summary">
    
    

    

    
        
        <li class="header">入门篇</li>
        
        
    
        <li class="chapter " data-level="1.1" data-path="../">
            
                <a href="../">
            
                    
                    Introduction
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="1.2" data-path="golang.html">
            
                <a href="golang.html">
            
                    
                    go 语言入门
            
                </a>
            

            
        </li>
    
        <li class="chapter active" data-level="1.3" data-path="quickstart.html">
            
                <a href="quickstart.html">
            
                    
                    算法快速入门
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">数据结构篇</li>
        
        
    
        <li class="chapter " data-level="2.1" data-path="../data_structure/binary_tree.html">
            
                <a href="../data_structure/binary_tree.html">
            
                    
                    二叉树
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.2" data-path="../data_structure/linked_list.html">
            
                <a href="../data_structure/linked_list.html">
            
                    
                    链表
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.3" data-path="../data_structure/stack_queue.html">
            
                <a href="../data_structure/stack_queue.html">
            
                    
                    栈和队列
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="2.4" data-path="../data_structure/binary_op.html">
            
                <a href="../data_structure/binary_op.html">
            
                    
                    二进制
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">基础算法篇</li>
        
        
    
        <li class="chapter " data-level="3.1" data-path="../basic_algorithm/binary_search.html">
            
                <a href="../basic_algorithm/binary_search.html">
            
                    
                    二分搜索
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.2" data-path="../basic_algorithm/sort.html">
            
                <a href="../basic_algorithm/sort.html">
            
                    
                    排序算法
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="3.3" data-path="../basic_algorithm/dp.html">
            
                <a href="../basic_algorithm/dp.html">
            
                    
                    动态规划
            
                </a>
            

            
        </li>
    

    
        
        <li class="header">算法思维</li>
        
        
    
        <li class="chapter " data-level="4.1" data-path="../advanced_algorithm/recursion.html">
            
                <a href="../advanced_algorithm/recursion.html">
            
                    
                    递归思维
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.2" data-path="../advanced_algorithm/slide_window.html">
            
                <a href="../advanced_algorithm/slide_window.html">
            
                    
                    滑动窗口思想
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.3" data-path="../advanced_algorithm/binary_search_tree.html">
            
                <a href="../advanced_algorithm/binary_search_tree.html">
            
                    
                    二叉搜索树
            
                </a>
            

            
        </li>
    
        <li class="chapter " data-level="4.4" data-path="../advanced_algorithm/backtrack.html">
            
                <a href="../advanced_algorithm/backtrack.html">
            
                    
                    回溯法
            
                </a>
            

            
        </li>
    

    

    <li class="divider"></li>

    <li>
        <a href="https://github.com/honkit/honkit" target="blank" class="gitbook-link">
            本书使用 HonKit 发布
        </a>
    </li>
</ul>


                </nav>
            
        
    </div>

    <div class="book-body">
        
            <div class="body-inner">
                
                    

<div class="book-header" role="navigation">
    

    <!-- Title -->
    <h1>
        <i class="fa fa-circle-o-notch fa-spin"></i>
        <a href=".." >算法快速入门</a>
    </h1>
</div>




                    <div class="page-wrapper" tabindex="-1" role="main">
                        <div class="page-inner">
                            
<div id="book-search-results">
    <div class="search-noresults">
    
                                <section class="normal markdown-section">
                                
                                <h1 id="快速开始">快速开始</h1>
<h2 id="数据结构与算法">数据结构与算法</h2>
<p>数据结构是一种数据的表现形式，如链表、二叉树、栈、队列等都是内存中一段数据表现的形式。
算法是一种通用的解决问题的模板或者思路，大部分数据结构都有一套通用的算法模板，所以掌握这些通用的算法模板即可解决各种算法问题。</p>
<p>后面会分专题讲解各种数据结构、基本的算法模板、和一些高级算法模板，每一个专题都有一些经典练习题，完成所有练习的题后，你对数据结构和算法会有新的收获和体会。</p>
<p>先介绍两个算法题，试试感觉~</p>
<h3 id="示例-1：strstr"><a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank">示例 1：strStr</a></h3>
<blockquote>
<p>给定一个  haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从 0 开始)。如果不存在，则返回  -1。</p>
</blockquote>
<ul>
<li>思路：核心点遍历给定字符串字符，判断以当前字符开头字符串是否等于目标字符串</li>
</ul>
<pre><code class="lang-Rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-comment">// Solution 的公共方法，符合问题预期的接口。</span>
    <span class="hljs-comment">// 它接受 String 类型的拥有所有权的 haystack 和 needle。</span>
    <span class="hljs-comment">// 返回类型为 i32，按照问题的规范。</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">str_str</span>(haystack: <span class="hljs-type">String</span>, needle: <span class="hljs-type">String</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> {
        <span class="hljs-comment">// 在公共方法内部，将拥有所有权的 String 参数转换为字符串切片 (&amp;str)</span>
        <span class="hljs-comment">// 通过借用进行转换。这个转换是必要的，因为内部逻辑（在 str_str_impl 中）</span>
        <span class="hljs-comment">// 是基于字符串切片操作的，而不是拥有所有权的 String。</span>
        <span class="hljs-comment">// 这种方法避免了获取函数参数的所有权，</span>
        <span class="hljs-comment">// 允许我们使用引用来操作。</span>
        Solution::<span class="hljs-title function_ invoke__">str_str_impl</span>(&amp;haystack, &amp;needle)
    }

    <span class="hljs-comment">// 一个私有辅助函数，执行实际的计算。</span>
    <span class="hljs-comment">// 这个函数被设计为使用字符串切片 (&amp;str)，这对于只读操作如字符串搜索来说更为高效。</span>
    <span class="hljs-keyword">fn</span> <span class="hljs-title function_">str_str_impl</span>(haystack: &amp;<span class="hljs-type">str</span>, needle: &amp;<span class="hljs-type">str</span>) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">i32</span> {
        <span class="hljs-comment">// 检查 needle 是否为空字符串。</span>
        <span class="hljs-comment">// 根据问题定义，如果 needle 为空，</span>
        <span class="hljs-comment">// 函数应返回 0，表示在 haystack 的开始位置就匹配到了。</span>
        <span class="hljs-keyword">if</span> needle.<span class="hljs-title function_ invoke__">is_empty</span>() { <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; }

        <span class="hljs-comment">// 使用 find 方法搜索 haystack 中 needle 的第一次出现。</span>
        <span class="hljs-comment">// find 方法返回一个 Option&lt;usize&gt; 类型：</span>
        <span class="hljs-comment">// - Some(index) 如果找到了 needle，其中 index 是起始位置。</span>
        <span class="hljs-comment">// - None 如果没有找到 needle。</span>
        <span class="hljs-comment">// 然后使用 Option 上的 map_or 方法来处理这两种情况：</span>
        <span class="hljs-comment">// - 如果是 Some(index)，则转换为 index 的 i32 类型。</span>
        <span class="hljs-comment">// - 如果是 None（没有找到 needle），则返回 -1。</span>
        haystack.<span class="hljs-title function_ invoke__">find</span>(needle).<span class="hljs-title function_ invoke__">map_or</span>(-<span class="hljs-number">1</span>, |v| v <span class="hljs-keyword">as</span> <span class="hljs-type">i32</span>)
    }
}
</code></pre>
<p>需要注意点</p>
<ul>
<li>通过在接口边界将 String 转换为 &amp;str，代码高效处理字符串数据，无需不必要的克隆或所有权转移。。</li>
<li>错误处理：<ul>
<li>Rust 通过 Result 和 Option 枚举强制进行错误处理，这与 Python 的异常处理机制不同。</li>
<li>需要习惯使用 match 或 if let 表达式来处理这些枚举的值。</li>
</ul>
</li>
<li>不可变性：<ul>
<li>Rust 中的变量默认是不可变的。如果你需要修改变量的值，需要在声明时使用 mut 关键字。</li>
</ul>
</li>
</ul>
<h3 id="示例-2：subsets"><a href="https://leetcode-cn.com/problems/subsets/" target="_blank">示例 2：subsets</a></h3>
<blockquote>
<p>给定一组不含重复元素的整数数组 nums，返回该数组所有可能的子集（幂集）。</p>
</blockquote>
<ul>
<li>思路：这是一个典型的应用回溯法的题目，简单来说就是穷尽所有可能性，算法模板如下</li>
</ul>
<pre><code class="lang-go">result = []
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">backtrack</span><span class="hljs-params">(选择列表,路径)</span></span>:
    <span class="hljs-keyword">if</span> 满足结束条件:
        result.add(路径)
        <span class="hljs-keyword">return</span>
    <span class="hljs-keyword">for</span> 选择 in 选择列表:
        做选择
        backtrack(选择列表,路径)
        撤销选择
</code></pre>
<ul>
<li>通过不停的选择，撤销选择，来穷尽所有可能性，最后将满足条件的结果返回。答案代码：</li>
</ul>
<pre><code class="lang-Rust"><span class="hljs-keyword">impl</span> <span class="hljs-title class_">Solution</span> {
    <span class="hljs-comment">// 定义一个公共的静态方法 `subsets`，该方法接收一个 Vec&lt;i32&gt; 类型的参数 `nums`，</span>
    <span class="hljs-comment">// 表示一组整数，返回一个 Vec&lt;Vec&lt;i32&gt;&gt; 类型，表示所有可能的子集合。</span>
    <span class="hljs-keyword">pub</span> <span class="hljs-keyword">fn</span> <span class="hljs-title function_">subsets</span>(nums: <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;) <span class="hljs-punctuation">-&gt;</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt; {
        <span class="hljs-comment">// 定义一个动态数组 `result` 用于存储最终的所有子集结果。</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">result</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();

        <span class="hljs-comment">// 定义一个内部的递归函数 `backtrack` 用于回溯搜索子集。</span>
        <span class="hljs-comment">// 它接受一个整数数组的切片 `nums`、一个起始索引 `start`、一个当前路径的可变引用 `route`，</span>
        <span class="hljs-comment">// 以及一个最终结果的可变引用 `result`。</span>
        <span class="hljs-keyword">fn</span> <span class="hljs-title function_">backtrack</span>(nums: &amp;[<span class="hljs-type">i32</span>], start: <span class="hljs-type">usize</span>, route: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;, result: &amp;<span class="hljs-keyword">mut</span> <span class="hljs-type">Vec</span>&lt;<span class="hljs-type">Vec</span>&lt;<span class="hljs-type">i32</span>&gt;&gt;) {
            <span class="hljs-comment">// 将当前路径的一个克隆添加到结果集中。</span>
            <span class="hljs-comment">// 这一步确保了在每次递归调用中，当前探索的路径都会被记录下来。</span>
            result.<span class="hljs-title function_ invoke__">push</span>(route.<span class="hljs-title function_ invoke__">clone</span>());

            <span class="hljs-comment">// 从 `start` 索引开始遍历 `nums` 数组。</span>
            <span class="hljs-keyword">for</span> <span class="hljs-variable">i</span> <span class="hljs-keyword">in</span> start..nums.<span class="hljs-title function_ invoke__">len</span>() {
                <span class="hljs-comment">// 将当前数字添加到路径中。</span>
                route.<span class="hljs-title function_ invoke__">push</span>(nums[i]);
                <span class="hljs-comment">// 递归调用 `backtrack` 函数，i + 1 保证下一次调用时，搜索的范围向前推进了一步。</span>
                <span class="hljs-title function_ invoke__">backtrack</span>(nums, i + <span class="hljs-number">1</span>, route, result);
                <span class="hljs-comment">// 回溯：将路径中最后一个数字移除，探索不包含当前数字的其他路径。</span>
                route.<span class="hljs-title function_ invoke__">pop</span>();
            }
        }

        <span class="hljs-comment">// 定义一个动态数组 `route` 用于记录当前搜索的路径。</span>
        <span class="hljs-keyword">let</span> <span class="hljs-keyword">mut </span><span class="hljs-variable">route</span> = <span class="hljs-type">Vec</span>::<span class="hljs-title function_ invoke__">new</span>();
        <span class="hljs-comment">// 调用 `backtrack` 函数开始搜索，从索引 0 和空路径开始。</span>
        <span class="hljs-title function_ invoke__">backtrack</span>(&amp;nums, <span class="hljs-number">0</span>, &amp;<span class="hljs-keyword">mut</span> route, &amp;<span class="hljs-keyword">mut</span> result);

        <span class="hljs-comment">// 返回最终收集到的所有子集结果。</span>
        result
    }
}
</code></pre>
<p>说明：后面会深入讲解几个典型的回溯算法问题，如果当前不太了解可以暂时先跳过</p>
<h2 id="面试注意点">面试注意点</h2>
<p>我们大多数时候，刷算法题可能都是为了准备面试，所以面试的时候需要注意一些点</p>
<ul>
<li>快速定位到题目的知识点，找到知识点的<strong>通用模板</strong>，可能需要根据题目<strong>特殊情况做特殊处理</strong>。</li>
<li>先去朝一个解决问题的方向！<strong>先抛出可行解</strong>，而不是最优解！先解决，再优化！</li>
<li>代码的风格要统一，熟悉各类语言的代码规范。<ul>
<li>命名尽量简洁明了，尽量不用数字命名如：i1、node1、a1、b2</li>
</ul>
</li>
<li>常见错误总结<ul>
<li>访问下标时，不能访问越界</li>
<li>空值 nil 问题 run time error</li>
</ul>
</li>
</ul>
<h2 id="练习">练习</h2>
<ul>
<li>[ ] <a href="https://leetcode-cn.com/problems/implement-strstr/" target="_blank">strStr</a></li>
<li>[ ] <a href="https://leetcode-cn.com/problems/subsets/" target="_blank">subsets</a></li>
</ul>

                                
                                </section>
                            
    </div>
    <div class="search-results">
        <div class="has-results">
            
            <h1 class="search-results-title"><span class='search-results-count'></span> results matching "<span class='search-query'></span>"</h1>
            <ul class="search-results-list"></ul>
            
        </div>
        <div class="no-results">
            
            <h1 class="search-results-title">No results matching "<span class='search-query'></span>"</h1>
            
        </div>
    </div>
</div>

                        </div>
                    </div>
                
            </div>

            
                
                <a href="golang.html" class="navigation navigation-prev " aria-label="Previous page: go 语言入门">
                    <i class="fa fa-angle-left"></i>
                </a>
                
                
                <a href="../data_structure/binary_tree.html" class="navigation navigation-next " aria-label="Next page: 二叉树">
                    <i class="fa fa-angle-right"></i>
                </a>
                
            
        
    </div>

    <script>
        var gitbook = gitbook || [];
        gitbook.push(function() {
            gitbook.page.hasChanged({"page":{"title":"算法快速入门","level":"1.3","depth":1,"next":{"title":"二叉树","level":"2.1","depth":1,"path":"data_structure/binary_tree.md","ref":"data_structure/binary_tree.md","articles":[]},"previous":{"title":"go 语言入门","level":"1.2","depth":1,"path":"introduction/golang.md","ref":"introduction/golang.md","articles":[]},"dir":"ltr"},"config":{"plugins":["livereload"],"root":".","styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"pluginsConfig":{"livereload":{},"highlight":{},"search":{},"lunr":{"maxIndexSize":1000000,"ignoreSpecialCharacters":false},"fontsettings":{"theme":"white","family":"sans","size":2},"theme-default":{"styles":{"website":"styles/website.css","pdf":"styles/pdf.css","epub":"styles/epub.css","mobi":"styles/mobi.css","ebook":"styles/ebook.css","print":"styles/print.css"},"showLevel":false}},"theme":"default","author":"JiangMing","pdf":{"pageNumbers":true,"fontSize":12,"fontFamily":"Arial","paperSize":"a4","chapterMark":"pagebreak","pageBreaksBefore":"/","margin":{"right":62,"left":62,"top":56,"bottom":56},"embedFonts":false},"structure":{"langs":"LANGS.md","readme":"README.md","glossary":"GLOSSARY.md","summary":"SUMMARY.md"},"isbn":"000-0-00-000000-0","variables":{},"title":"JiangMing Gitbook","language":"zh-hans","gitbook":">=3.2.3","description":"This is gitbook","direction":"ltr"},"file":{"path":"introduction/quickstart.md","mtime":"2024-03-30T03:57:41.061Z","type":"markdown"},"gitbook":{"version":"5.1.4","time":"2024-03-30T04:52:35.739Z"},"basePath":"..","book":{"language":""}});
        });
    </script>
</div>

        
    <noscript>
        <style>
            .honkit-cloak {
                display: block !important;
            }
        </style>
    </noscript>
    <script>
        // Restore sidebar state as critical path for prevent layout shift
        function __init__getSidebarState(defaultValue){
            var baseKey = "";
            var key = baseKey + ":sidebar";
            try {
                var value = localStorage[key];
                if (value === undefined) {
                    return defaultValue;
                }
                var parsed = JSON.parse(value);
                return parsed == null ? defaultValue : parsed;
            } catch (e) {
                return defaultValue;
            }
        }
        function __init__restoreLastSidebarState() {
            var isMobile = window.matchMedia("(max-width: 600px)").matches;
            if (isMobile) {
                // Init last state if not mobile
                return;
            }
            var sidebarState = __init__getSidebarState(true);
            var book = document.querySelector(".book");
            // Show sidebar if it enabled
            if (sidebarState && book) {
                book.classList.add("without-animation", "with-summary");
            }
        }

        try {
            __init__restoreLastSidebarState();
        } finally {
            var book = document.querySelector(".book");
            book.classList.remove("honkit-cloak");
        }
    </script>
    <script src="../gitbook/gitbook.js"></script>
    <script src="../gitbook/theme.js"></script>
    
        
        <script src="../gitbook/gitbook-plugin-livereload/plugin.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search-engine.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-search/search.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/lunr.min.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-lunr/search-lunr.js"></script>
        
    
        
        <script src="../gitbook/gitbook-plugin-fontsettings/fontsettings.js"></script>
        
    

    </body>
</html>

